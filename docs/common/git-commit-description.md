# Правила оформления сообщений коммита

## Алгоритм

1. Выполнить `git status` и убедиться, что есть staged файлы. Если нет — попросить добавить через `git add`.
2. Изучить изменения командой `git diff --staged`, чтобы понять что и зачем изменено. Если diff пуст — вывести «Нет файлов, добавленных для коммита.» и завершить. Один коммит — одна логическая задача; крупные изменения дробить.
3. Сформировать заголовок по Conventional Commits: `type(scope): описание` или `type: описание` (scope опционален). `type` — из списка ниже, строчными буквами. `scope` — строчными, коротко. `описание` — на русском, с маленькой буквы, в повелительном наклонении, максимум 50 символов с учётом префикса, без точки и двоеточий. Допустимо сохранять регистр имен собственных и идентификаторов (например, `UserProfile`, `API Gateway`, `POST /users`) внутри описания.
4. Отметить breaking change, если есть: либо `type(scope)!: описание`, либо добавить в теле строку/блок `BREAKING CHANGE: ...` (см. ниже).
5. После заголовка оставить пустую строку.
6. В теле — маркированный список уже сделанных изменений, описывающий ЧТО изменено и ПОЧЕМУ (не КАК; прошедшее время) и причин, опираясь на diff. Строки тела — максимум 72 символа. Упоминать конкретные компоненты/конфиги/плагины и стековые термины; называть затронутые файлы/компоненты их реальными именами с сохранением регистра идентификаторов (например, `UserProfile`, `API Gateway`, `POST /users`). Ссылки на issue в теле не указывать.
7. При необходимости отката использовать формат `revert: <заголовок откатываемого коммита>` и в теле указывать хеш: `This reverts commit <hash>.`
8. При наличии задачи/issue вынести её в футер формата `Closes #123` или `Fixes #123`, отделив футер от тела пустой строкой. Каждая ссылка на задачу — отдельной строкой футера.
9. **Показать полное описание коммита в виде блока кода** и дождаться подтверждения от пользователя. Если пользователь указывает на необходимость изменений, внести изменения, показать обновлённое описание и снова ждать подтверждения. Повторять процесс до получения подтверждения.
10. **Только после подтверждения** создать файл `.git-commit-msg.txt` в корне проекта с полным текстом сообщения коммита в кодировке **UTF-8 без BOM**. Использовать команду `git commit -F .git-commit-msg.txt` для создания коммита (или `git merge --no-ff <branch> -F .git-commit-msg.txt` для merge-коммитов). После успешного коммита удалить файл `.git-commit-msg.txt`.

**КРИТИЧЕСКИ ВАЖНО**:

- **Перед созданием файла `.git-commit-msg.txt` ВСЕГДА показать описание коммита в виде блока кода и дождаться явного подтверждения от пользователя.**
- Если пользователь указывает на необходимость изменений, внести изменения, показать обновлённое описание и снова ждать подтверждения.
- Повторять процесс показа описания и ожидания подтверждения до получения явного одобрения.
- Только после подтверждения создавать файл и выполнять коммит.

**Важно**: Файл `.git-commit-msg.txt` должен быть в кодировке UTF-8 без BOM. В Windows при создании файла через редактор (например, VS Code) убедитесь, что кодировка установлена на "UTF-8" (не "UTF-8 with BOM"). В PowerShell можно создать файл командой: `[System.IO.File]::WriteAllText('.git-commit-msg.txt', $content, [System.Text.UTF8Encoding]::new($false))`.

## Формат сообщения

- Строка 1: `type(scope): описание` (scope опционален). `type` — из списка: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`, `revert`. Всё в нижнем регистре. `scope` в круглых скобках, нижний регистр, кратко. `описание` — на русском, с маленькой буквы, в повелительном наклонении, максимум 50 символов с учётом префикса, без точки и двоеточий. Разрешено сохранять регистр имен собственных и идентификаторов внутри описания (например, `UserProfile`, `API Gateway`, `POST /users`); при этом начало описания остаётся со строчной буквы, если не начинается с идентификатора.
- Для breaking change: либо `type(scope)!: описание`, либо в теле отдельный абзац/строка `BREAKING CHANGE: описание`, отделённый пустой строкой.
- Для откатов: `revert: <заголовок откатываемого коммита>`; в теле первой строкой `This reverts commit <hash>.`
- Строка 2: Пустая.
- Далее: Список маркеров с деталями уже выполненных изменений (прошедшее время) и мотивацией. Строки списка — максимум 72 символа. Явно называть изменённые файлы/компоненты/конфиги/плагины их реальными именами с сохранением регистра идентификаторов (например, `UserProfile`, `API Gateway`, `POST /users`).
- Далее (опционально): Пустая строка и футер с ссылками на задачи в формате `Closes #123` или `Fixes #123`. Если задач несколько — каждая ссылка с новой строки футера.

## Выбор scope

Scope должен отражать область кодовой базы, на которую влияет изменение. Выбирать кратко и строчными буквами:

- **Модуль/компонент**: `ui`, `auth`, `api`, `database`, `profile`
- **Функциональная область**: `weather`, `payment`, `notification`
- **Конфигурация/инструменты**: `config`, `build`, `ci`, `lint`
- **Документация**:
  - `docs(commit):` — для документации о правилах коммитов
  - `docs(api):` — для документации API
  - `docs(readme):` — для README файлов
  - `docs:` — без scope, если документация общая или scope неочевиден

При выборе scope ориентироваться на:

- Имя изменённого файла/компонента (если оно отражает область)
- Функциональную область, на которую влияет изменение
- Модуль или подсистему проекта

## Примеры

- Для новых файлов: `feat(ui): добавить компонент UserProfile`
- Для исправлений: `fix(auth): исправить обработку expired токена`
- Для рефакторинга: `refactor(api): упростить построение payload`
- Для стилей: `style(app): выровнять отступы в layout`
- Для тестов: `test(api): покрыть ошибку 404 e2e`
- Для настроек: `chore(config): настроить lint-staged`
- Для документации о коммитах: `docs(commit): обновить формат сообщений коммита`
- Для документации API: `docs(api): добавить описание эндпоинта /users`
- Для отката: `revert: feat(ui): добавить компонент UserProfile`
- Для breaking change: `feat(auth)!: обновить протокол refresh`

## Процесс подтверждения описания коммита

Перед созданием файла `.git-commit-msg.txt` и выполнением коммита ассистент должен:

1. Показать полное описание коммита в виде блока кода
2. Явно спросить подтверждение (например: "Применить это описание коммита?", "Создать коммит с этим описанием?", "Продолжить?")
3. Дождаться явного ответа пользователя (да/нет/ок/применить и т.п.)
4. Если пользователь указывает на необходимость изменений:
   - Внести изменения в описание
   - Показать обновлённое описание в виде блока кода
   - Снова спросить подтверждение
   - Повторять до получения подтверждения
5. Только после подтверждения создавать файл и выполнять коммит

**Пример диалога:**

```
Ассистент: Вот описание коммита:

```

fix(auth): исправить обработку expired токена

- корректно обрабатывать истёкшие токены и перенаправлять на страницу входа
- добавить логирование для отладки

```

Применить это описание коммита?

Пользователь: измени scope на "token"

Ассистент: Вот обновлённое описание коммита:

```

fix(token): исправить обработку expired токена

- корректно обрабатывать истёкшие токены и перенаправлять на страницу входа
- добавить логирование для отладки

```

Применить это описание коммита?

Пользователь: да

Ассистент: [создаёт файл .git-commit-msg.txt и выполняет коммит]
```

```
feat(weather): добавить кэширование погоды

- сохранить ответы API в память на 5 минут, чтобы снизить нагрузку
- использовать кэш только для успешных ответов
- обновить тесты для проверки работы кэша

Closes #123
```

```
fix(profile): исправить ошибку загрузки профиля

- корректно обрабатывать 404 и показывать уведомление пользователю
- добавить логирование кода ответа сервера
- обновить e2e-тест на сценарий отсутствующего профиля
```

```
feat(auth)!: обновить протокол refresh

- добавить повторную валидацию рефреш-токена на сервере
- сменить схему ответа /refresh на unified payload

BREAKING CHANGE: новый формат ответа /refresh требует обновить клиент
```
