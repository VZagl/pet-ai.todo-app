# Настройки тестирования

## Фреймворк тестирования

- **Vitest**: `^4.0.16` — быстрый фреймворк тестирования, совместимый с Vite.

## Зависимости для тестирования

- **@testing-library/react**: `^16.3.1` — утилиты для тестирования React-компонентов.
- **@testing-library/jest-dom**: `^6.9.1` — дополнительные матчеры для DOM-элементов (например, `toBeInTheDocument`, `toHaveClass`).
- **@testing-library/user-event**: `^14.6.1` — симуляция пользовательских событий (клики, ввод текста и т.д.).
- **jsdom**: `^27.3.0` — окружение DOM для тестов.
- **@vitest/ui**: `^4.0.16` — UI для просмотра и отладки тестов.

## Конфигурация

Конфигурация Vitest находится в `vite.config.ts`:

- `globals: true` — глобальные функции тестирования (`test`, `expect`, `describe` и т.д.) доступны без импорта.
- `environment: 'jsdom'` — использование jsdom для эмуляции браузерного окружения.
- `setupFiles: ['./vitest.setup.ts']` — файл настройки, который выполняется перед каждым тестом (настраивает `@testing-library/jest-dom`).

## Скрипты

- `pnpm test` — запуск тестов в watch-режиме.
- `pnpm test:ui` — запуск тестов с UI-интерфейсом для просмотра результатов.
- `pnpm test:coverage` — запуск тестов с генерацией отчёта о покрытии кода.

## Структура тестов

Тесты должны находиться рядом с тестируемыми файлами или в директории `__tests__`:

- `Component.test.tsx` или `Component.spec.tsx` — рядом с компонентом.
- `__tests__/Component.test.tsx` — в отдельной директории для тестов.

## Правила пользовательских событий

- Ввод текста и нажатие Enter выполняются раздельно:
  - Сначала `await user.type(input, 'Текст')`
  - Затем `await user.keyboard('{Enter}')`
  - Не использовать `{Enter}` внутри `user.type`, если цель — отправка формы

## Избегание ложноположительных совпадений

При поиске элементов в тестах важно ограничивать область поиска, чтобы избежать ложноположительных совпадений. Это особенно критично при работе с числами и общими текстовыми фразами.

### Проблема с поиском по числам

Поиск по "голым" числам (например, `getByText('5')`) может найти элемент в любой части документа, включая названия задач, что приводит к ложноположительным совпадениям.

**❌ Неправильно:**

```typescript
// Поиск может найти число в названии задачи, а не в счетчике
expect(screen.getByText('5')).toBeInTheDocument();
```

**✅ Правильно:**

```typescript
// Ограничение поиска до конкретной области (footer)
const footer = screen.getByRole('contentinfo');
expect(within(footer).getByText('5')).toBeInTheDocument();
```

### Проблема с общими текстовыми совпадениями

Текстовые фразы, которые могут встречаться в разных частях интерфейса (например, "осталось"), также требуют ограничения области поиска.

**❌ Неправильно:**

```typescript
// Поиск может найти текст в названии задачи
expect(screen.getByText('осталось')).toBeInTheDocument();
```

**✅ Правильно:**

```typescript
// Ограничение поиска до footer элемента
const footer = screen.getByRole('contentinfo');
expect(within(footer).getByText('осталось')).toBeInTheDocument();
```

### Использование `within()` для ограничения области поиска

`within()` из `@testing-library/react` позволяет ограничить поиск элементов до конкретного контейнера:

```typescript
import { render, screen, within } from '@testing-library/react';

test('проверяет счетчик в footer', () => {
  render(<Component />);

  // Получаем контейнер (footer, section, div и т.д.)
  const footer = screen.getByRole('contentinfo');

  // Ищем элементы только внутри этого контейнера
  expect(within(footer).getByText('5')).toBeInTheDocument();
  expect(within(footer).getByText('задач осталось')).toBeInTheDocument();
});
```

### Проверка отсутствия ложноположительных совпадений

**КРИТИЧЕСКИ ВАЖНО:** Для убедительной проверки отсутствия ложноположительных совпадений недостаточно проверять только наличие значения в нужном месте. Необходимо создавать тестовые сценарии, где искомое значение присутствует в других местах интерфейса, и проверять, что:

1. **Значение присутствует в правильном месте** (позитивная проверка)
2. **Значение отсутствует в неправильных местах** (негативная проверка)

Это гарантирует, что тест действительно проверяет конкретный элемент, а не случайное совпадение.

**Пример правильного теста:**

```typescript
test('счетчик отображается только в footer, а не в названиях задач', async () => {
  const user = userEvent.setup();
  render(<TodoApp />);

  // Создаем ситуацию, когда число "5" может быть в разных местах
  const input = screen.getByPlaceholderText(/что нужно сделать/i);
  await user.type(input, 'Задача номер 5');
  await user.click(screen.getByRole('button', { name: /добавить/i }));

  // Добавляем еще задачи, чтобы счетчик стал "5"
  for (let i = 1; i <= 4; i++) {
    await user.type(input, `Задача ${i}`);
    await user.click(screen.getByRole('button', { name: /добавить/i }));
  }

  // Позитивная проверка: число "5" есть в footer (счетчик)
  const footer = screen.getByRole('contentinfo');
  expect(within(footer).getByText('5')).toBeInTheDocument();

  // Негативная проверка: число "5" НЕ находится в других местах через общий поиск
  // (это подтверждает, что within() действительно ограничивает поиск)
  const allFives = screen.queryAllByText('5');
  // Должно быть ровно 2 вхождения: одно в названии задачи, одно в счетчике
  expect(allFives).toHaveLength(2);

  // Проверяем, что счетчик действительно в footer, а не в списке задач
  const taskList = screen.getByRole('list');
  expect(within(taskList).getByText('5')).toBeInTheDocument(); // В названии задачи
  expect(within(footer).getByText('5')).toBeInTheDocument(); // В счетчике
  // Оба элемента существуют, но within() позволяет различить их
});
```

**Правило для ИИ:**

При написании тестов для проверки элементов, которые могут иметь ложноположительные совпадения (числа, общие фразы):

1. **Создайте конфликтную ситуацию**: добавьте в тест данные, где искомое значение (число, текст) присутствует в других местах интерфейса
2. **Проверьте наличие в правильном месте**: используйте `within()` для проверки, что значение есть в нужном контейнере
3. **Проверьте контекст**: убедитесь, что значение находится именно там, где ожидается, а не в других местах
4. **Используйте негативные проверки**: при необходимости проверяйте, что значение не находится в неправильных местах через `queryByText` или `queryAllByText`

Это правило гарантирует, что тесты действительно проверяют конкретные элементы, а не случайные совпадения по всему документу.

### Рекомендации

- **Всегда используйте `within()`** при поиске чисел или общих текстовых фраз, если они могут встречаться в разных частях интерфейса
- **Используйте семантические роли** (`getByRole`) для получения контейнеров, когда это возможно
- **Комбинируйте `within()` с другими методами поиска** для более точных проверок
- **Создавайте конфликтные тестовые сценарии**: добавляйте данные, где искомое значение может присутствовать в разных местах, чтобы убедиться, что тест проверяет правильный элемент

## Работа с моками

При использовании моков в тестах важно правильно управлять их жизненным циклом, чтобы предотвратить утечки моков между тестами и обеспечить надёжность тестового окружения.

### Автоматическая очистка моков через `afterEach`

**КРИТИЧЕСКИ ВАЖНО:** Всегда используйте `afterEach` hook с `vi.restoreAllMocks()` для автоматической очистки всех моков после каждого теста. Это гарантирует, что моки будут восстановлены даже если тест упадёт до завершения.

**❌ Неправильно:**

```typescript
import { describe, expect, it, vi } from 'vitest';

describe('Component', () => {
	it('тест с моком', () => {
		const spy = vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
			throw new Error('QuotaExceededError');
		});

		// Если тест упадёт здесь, spy.mockRestore() не выполнится
		expect(() => someFunction()).toThrow();

		// Ручное восстановление - может не выполниться при падении теста
		spy.mockRestore();
	});
});
```

**✅ Правильно:**

```typescript
import { afterEach, describe, expect, it, vi } from 'vitest';

describe('Component', () => {
	afterEach(() => {
		vi.restoreAllMocks();
	});

	it('тест с моком', () => {
		// Мок будет автоматически восстановлен после теста
		vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
			throw new Error('QuotaExceededError');
		});

		expect(() => someFunction()).toThrow();
		// Не нужно вызывать spy.mockRestore() - это делает afterEach
	});
});
```

### Разница между `vi.clearAllMocks()` и `vi.restoreAllMocks()`

Важно понимать разницу между этими методами:

- **`vi.clearAllMocks()`** — очищает только историю вызовов моков, но не восстанавливает оригинальные реализации. Используется в `beforeEach` для подготовки чистого состояния перед каждым тестом.

- **`vi.restoreAllMocks()`** — восстанавливает оригинальные реализации всех моков, созданных через `vi.spyOn()`. Используется в `afterEach` для гарантированной очистки после каждого теста.

**Пример правильного использования:**

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

describe('storage utils', () => {
	beforeEach(() => {
		// Очистка localStorage перед каждым тестом
		localStorage.clear();
		// Очистка истории вызовов моков (но не восстановление)
		vi.clearAllMocks();
	});

	afterEach(() => {
		// Восстановление оригинальных реализаций всех моков
		vi.restoreAllMocks();
	});

	it('тест с моком', () => {
		// Мок создаётся внутри теста
		vi.spyOn(Storage.prototype, 'setItem').mockImplementation(() => {
			throw new Error('QuotaExceededError');
		});

		expect(() => saveToStorage('key', 'data')).toThrow();
		// Мок будет автоматически восстановлен в afterEach
	});
});
```

### Почему это важно

1. **Надёжность тестов**: Если тест упадёт до вызова `mockRestore()`, мок останется активным и может повлиять на другие тесты.

2. **Предотвращение side effects**: Автоматическая очистка гарантирует, что моки не "утекут" между тестами и не вызовут неожиданное поведение.

3. **Изоляция тестов**: Каждый тест должен быть независимым. Автоматическая очистка моков помогает обеспечить эту изоляцию.

### Рекомендации

- **Всегда используйте `afterEach(() => { vi.restoreAllMocks(); })`** в файлах с тестами, где используются моки
- **Не используйте ручные вызовы `spy.mockRestore()`** — они избыточны при наличии `afterEach`
- **Используйте `beforeEach` с `vi.clearAllMocks()`** для очистки истории вызовов перед каждым тестом (если нужно)
- **Не сохраняйте ссылки на spy**, если они не используются — `vi.restoreAllMocks()` восстановит все моки автоматически

## Использование констант в тестах

**КРИТИЧЕСКИ ВАЖНО:** При написании тестов всегда проверяйте наличие констант для значений, которые используются в основном коде. Если константа существует, используйте её вместо жёстко прописанных строк или значений.

### Проблема с жёстко прописанными значениями

Использование жёстко прописанных строк или значений в тестах создаёт дублирование и нарушает принцип единого источника истины (Single Source of Truth). Это приводит к необходимости рефакторинга и усложняет поддержку кода.

**❌ Неправильно:**

```typescript
// Жёстко прописанная строка 'todos' вместо константы
const stored = localStorage.getItem('todos');
localStorage.setItem('todos', JSON.stringify(data));
```

**✅ Правильно:**

```typescript
// Использование константы STORAGE_KEY из constants/todo.ts
import { STORAGE_KEY } from '../constants/todo';

const stored = localStorage.getItem(STORAGE_KEY);
localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
```

### Когда использовать константы

Константы должны использоваться для:

- **Ключей localStorage/sessionStorage**: если в проекте есть константы для ключей хранения (например, `STORAGE_KEY`), всегда используйте их в тестах
- **API endpoints**: если есть константы для URL эндпоинтов, используйте их вместо жёстко прописанных строк
- **Магических чисел**: если в коде есть константы для числовых значений (например, `MAX_TODO_LENGTH`, `TIMEOUT_MS`), используйте их
- **Строковых идентификаторов**: если есть константы для идентификаторов (например, `FILTER_TYPES`, `STATUS_CODES`), используйте их

### Правило для ИИ

При написании или рефакторинге тестов:

1. **Проверьте наличие констант ПЕРЕД написанием теста**: перед использованием любого жёстко прописанного значения в тесте проверьте, существует ли соответствующая константа в проекте
   - Проверьте файлы в директории `src/constants/` или аналогичных
   - Проверьте, используется ли константа в основном коде (компонентах, хуках, утилитах)
   - Если константа существует, используйте её

2. **Импортируйте константу в начале файла**: если константа существует, добавьте импорт в начало тестового файла

   ```typescript
   import { STORAGE_KEY } from '../constants/todo';
   ```

3. **Используйте константу вместо жёстко прописанных значений**: при написании теста используйте константу везде, где нужно значение

   ```typescript
   // НЕ пишите: localStorage.getItem('todos')
   // Пишите сразу: localStorage.getItem(STORAGE_KEY)
   ```

4. **Проверьте все места в тесте**: убедитесь, что используете константу во всех местах теста, где нужно значение:
   - `localStorage.getItem()`, `localStorage.setItem()`, `localStorage.removeItem()`
   - `sessionStorage.getItem()`, `sessionStorage.setItem()`, `sessionStorage.removeItem()`
   - Любые другие места, где используется значение

### Пример правильного создания теста

**✅ Правильно — использование константы с самого начала:**

```typescript
// src/hooks/useTodos.test.ts
import { STORAGE_KEY } from '../constants/todo'; // Импорт константы в начале

describe('useTodos', () => {
  it('должен сохранять задачи в localStorage', () => {
    // Использование константы STORAGE_KEY с самого начала
    const stored = localStorage.getItem(STORAGE_KEY);
    expect(stored).not.toBeNull();
  });

  it('должен загружать задачи из localStorage', () => {
    // Использование константы STORAGE_KEY с самого начала
    localStorage.setItem(STORAGE_KEY, JSON.stringify([...]));
  });
});
```

**❌ Неправильно — использование жёстко прописанных значений:**

```typescript
// src/hooks/useTodos.test.ts
// Нет импорта константы

describe('useTodos', () => {
	it('должен сохранять задачи в localStorage', () => {
		// Жёстко прописанная строка 'todos' - НЕПРАВИЛЬНО
		const stored = localStorage.getItem('todos');
		expect(stored).not.toBeNull();
	});
});
```

### Алгоритм проверки для ИИ

При создании нового теста, который использует значения (строки, числа, идентификаторы):

1. **Определите, какое значение нужно использовать** (например, ключ localStorage, URL endpoint, числовое значение)
2. **Проверьте наличие константы**:
   - Изучите файлы в `src/constants/` или аналогичных директориях
   - Проверьте, используется ли константа в тестируемом коде (компоненте, хуке, утилите)
   - Используйте поиск по проекту для проверки существования константы
3. **Если константа существует**:
   - Добавьте импорт константы в начало тестового файла
   - Используйте константу вместо жёстко прописанного значения
4. **Если константы нет, но она используется в основном коде**:
   - Найдите, где определена константа в основном коде
   - Импортируйте её и используйте в тесте
5. **Если константы нет вообще**:
   - Рассмотрите возможность создания константы, если значение используется в нескольких местах
   - Если значение используется только в одном месте, можно использовать жёстко прописанное значение

### Почему это важно

1. **Единый источник истины**: константы обеспечивают единое место для определения значений, что упрощает поддержку кода
2. **Предотвращение ошибок**: если значение изменится, достаточно обновить его в одном месте (константе), а не во всех тестах
3. **Соответствие основному коду**: тесты должны использовать те же константы, что и основной код, для обеспечения консистентности
4. **Улучшение читаемости**: использование констант делает код более понятным и самодокументируемым
5. **Избежание рефакторинга**: использование констант с самого начала предотвращает необходимость последующего рефакторинга

### Рекомендации

- **Всегда проверяйте наличие констант** перед использованием жёстко прописанных значений в тестах
- **Используйте константы из того же модуля**, что и тестируемый код
- **Не используйте жёстко прописанные значения**, если для них существует константа
- **Если константа используется в основном коде**, она должна использоваться и в тестах
- **Не создавайте константы только для тестов** — если константа нужна только в тестах, возможно, стоит пересмотреть архитектуру

## Примеры использования

### Базовый тест компонента

```typescript
import { render, screen } from '@testing-library/react'
import { expect, test } from 'vitest'
import Component from './Component'

test('отображает текст', () => {
  render(<Component />)
  expect(screen.getByText('Текст')).toBeInTheDocument()
})
```

### Тест с пользовательскими событиями

```typescript
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { expect, test } from 'vitest'
import Button from './Button'

test('обрабатывает клик', async () => {
  const user = userEvent.setup()
  render(<Button onClick={() => alert('Клик!')} />)

  const button = screen.getByRole('button')
  await user.click(button)

  // Проверка результата клика
})
```

### Тест с асинхронными операциями

```typescript
import { render, screen, waitFor } from '@testing-library/react'
import { expect, test } from 'vitest'
import AsyncComponent from './AsyncComponent'

test('загружает данные', async () => {
  render(<AsyncComponent />)

  await waitFor(() => {
    expect(screen.getByText('Данные загружены')).toBeInTheDocument()
  })
})
```

## Дополнительные ресурсы

- [Документация Vitest](https://vitest.dev/)
- [Документация Testing Library](https://testing-library.com/)
- [React Testing Library](https://testing-library.com/react)
