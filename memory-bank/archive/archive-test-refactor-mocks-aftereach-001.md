# TASK ARCHIVE: Рефакторинг тестов - использование afterEach для очистки моков

## METADATA

- **Task ID:** test-refactor-mocks-aftereach-001
- **Complexity Level:** Level 1 - Quick Fix
- **Date Completed:** 2026-01-26
- **Date Archived:** 2026-01-26
- **Status:** ✅ COMPLETED & ARCHIVED

## SUMMARY

Выполнен рефакторинг тестов для автоматизации очистки моков через `afterEach` hook вместо ручных вызовов `mockRestore()`. Изменения внесены в два тестовых файла, все тесты проходят успешно (12/12 в изменённых файлах).

## REQUIREMENTS

### Функциональные требования (FR)

- ✅ **FR-01**: Добавлен `afterEach(() => { vi.restoreAllMocks(); })` в `src/utils/storage.test.ts`
- ✅ **FR-02**: Добавлен `afterEach(() => { vi.restoreAllMocks(); })` в `src/components/TodoList/TodoList.test.tsx`
- ✅ **FR-03**: Удалён ручной вызов `spy.mockRestore()` из `src/utils/storage.test.ts`
- ✅ **FR-04**: Удалён ручной вызов `consoleErrorSpy.mockRestore()` из `src/components/TodoList/TodoList.test.tsx`

### Нефункциональные требования (NFR)

- ✅ **NFR-01**: Повышение надёжности тестов - автоматическая очистка моков даже при падении теста
- ✅ **NFR-02**: Все существующие тесты проходят успешно (12/12)
- ✅ **NFR-03**: Предотвращение side effects между тестами

## IMPLEMENTATION

### Проблема

В текущих тестах использовался ручной вызов `spy.mockRestore()` после каждого теста с моками. Если тест падал до вызова `mockRestore()`, мок оставался активным и мог влиять на другие тесты, создавая side effects между тестами.

### Решение

Добавлен глобальный `afterEach(() => { vi.restoreAllMocks(); })` hook в оба тестовых файла для автоматической очистки всех моков после каждого теста.

### Изменённые файлы

#### Файл 1: `src/utils/storage.test.ts`

**Изменения:**

- Добавлен импорт `afterEach` в строку импортов
- Добавлен hook `afterEach(() => { vi.restoreAllMocks(); })` после `beforeEach`
- Удалён ручной вызов `spy.mockRestore()` (строка 42)

**Результат:**

- Автоматическая очистка моков после каждого теста
- Удаление ручного управления моками
- Все 7 тестов проходят успешно

#### Файл 2: `src/components/TodoList/TodoList.test.tsx`

**Изменения:**

- Добавлен импорт `afterEach` в строку импортов
- Добавлен hook `afterEach(() => { vi.restoreAllMocks(); })` в начало блока `describe`
- Удалён ручной вызов `consoleErrorSpy.mockRestore()` (строка 88)

**Результат:**

- Автоматическая очистка моков после каждого теста
- Удаление ручного управления моками
- Все 5 тестов проходят успешно

### Технические детали

**Почему `vi.restoreAllMocks()` вместо `vi.clearAllMocks()`:**

- `vi.spyOn()` создаёт spy, который заменяет оригинальную реализацию метода
- `clearAllMocks()` только очищает историю вызовов, но не восстанавливает оригинальную реализацию
- `restoreAllMocks()` восстанавливает оригинальные реализации всех моков, созданных через `spyOn()`
- Это критично для предотвращения утечки моков между тестами

**Почему `afterEach` вместо `beforeEach`:**

- `afterEach` гарантирует очистку моков даже если тест упадёт до завершения
- Это повышает надёжность тестов и предотвращает side effects между тестами
- `beforeEach` используется для подготовки (очистка localStorage, очистка истории вызовов), а `afterEach` - для восстановления состояния

## TESTING

### Результаты тестирования

**Запуск тестов:** `pnpm test`

**Результаты:**

- ✅ `src/utils/storage.test.ts`: **7/7 тестов прошли успешно**
- ✅ `src/components/TodoList/TodoList.test.tsx`: **5/5 тестов прошли успешно**
- ✅ Всего: **12/12 тестов в изменённых файлах проходят успешно**
- ✅ Моки автоматически очищаются после каждого теста
- ✅ Нет side effects между тестами

### Критерии успеха

- ✅ Все файлы с моками используют `afterEach(() => { vi.restoreAllMocks(); })`
- ✅ Все ручные вызовы `mockRestore()` удалены
- ✅ Все тесты в изменённых файлах проходят успешно (12/12)
- ✅ Повышение надёжности тестов (автоматическая очистка даже при падении теста)
- ✅ Соответствие требованиям из backlog

## LESSONS LEARNED

### Что сработало хорошо

1. **Простота реализации** - изменения были минимальными и понятными
2. **Немедленная польза** - автоматическая очистка моков повышает надёжность тестов
3. **Соответствие best practices** - использование `afterEach` для очистки является стандартной практикой в Vitest
4. **Отсутствие регрессий** - все существующие тесты продолжают работать корректно

### Вызовы и решения

**Вызов 1:** Определение правильного метода очистки моков  
**Решение:** Использован `vi.restoreAllMocks()` вместо `vi.clearAllMocks()`, так как `restoreAllMocks()` восстанавливает оригинальные реализации методов, созданных через `spyOn()`, что критично для предотвращения утечек моков.

**Вызов 2:** Убедиться, что изменения не сломают существующие тесты  
**Решение:** Все тесты были запущены после изменений, все 12 тестов в изменённых файлах проходят успешно.

### Ключевые уроки

1. **Автоматическая очистка лучше ручной** - `afterEach` гарантирует очистку даже при падении теста, что повышает надёжность
2. **Разница между `restoreAllMocks()` и `clearAllMocks()`** - важно понимать, что `restoreAllMocks()` восстанавливает оригинальные реализации, а `clearAllMocks()` только очищает историю вызовов
3. **Профилактика лучше лечения** - лучше автоматизировать очистку моков, чем полагаться на ручные вызовы

## METRICS

- **Время выполнения:** ~15 минут (быстрый рефакторинг)
- **Файлов изменено:** 2
- **Тестов:** 12/12 успешно (100%)
- **Регрессий:** 0
- **Соответствие требованиям:** 100%

## REFERENCES

- **Reflection Document:** `memory-bank/reflection/reflection-test-refactor-mocks-aftereach-001.md`
- **Task Tracking:** `memory-bank/tasks.md`
- **Progress Tracking:** `memory-bank/progress.md`
- **Backlog Reference:** `memory-bank/backlog.md`

## CONCLUSION

Рефакторинг успешно завершён. Все тесты используют автоматическую очистку моков через `afterEach` hook, что повышает надёжность тестов и предотвращает side effects между тестами. Задача соответствует всем требованиям и готова к использованию.
