# Рефлексия: Inline-редактирование текста задачи

**Task ID:** edit-task-001  
**Название:** Редактирование текста задачи  
**Дата рефлексии:** 2026-02-17  
**Уровень:** Level 2 — Simple Enhancement

---

## Краткое резюме

Реализовано inline-редактирование текста задачи в компоненте TodoItem. Единственный способ входа — кнопка редактирования (иконка карандаша) слева от кнопки удаления. Валидация: пустая строка и MAX_TODO_LENGTH. Enter — сохранить, Escape — отменить. Кнопки «Сохранить» (✓) и «Отмена» (×) с иконками и цветным фоном ($color-success, $color-primary). После выхода из режима редактирования кнопки редактирования и удаления остаются в разметке с `disabled` 400 ms — без layout shift. 15 тестов TodoItem проходят, сборка успешна.

---

## Что сработало хорошо

1. **План из 10 шагов** — детальный Implementation Plan в tasks.md с чекбоксами позволил выполнить задачу последовательно без пропусков; Challenges & Mitigations заранее определили риски (автофокус, Escape, layout shift, валидация).
2. **Подход disabled вместо show/hide** — кнопки редактирования и удаления всегда в DOM; при выходе из edit меняется только `disabled` с задержкой 400 ms. Это устранило layout shift и упростило тестирование (vi.useFakeTimers для проверки задержки).
3. **Рефакторинг кнопок (post-implementation)** — базовый класс `todo-item__btn` с модификаторами `--save`, `--cancel`, `--edit`, `--delete` устранил дублирование стилей; BEM-модификатор `todo-item__content--editing` на том элементе, который визуально меняется.
4. **edit-wrapper с flex: 1 0 auto** — решил проблему сжатия input до 0 при пустом тексте; input внутри с `width: 100%`, `box-sizing: border-box` обеспечивает корректную ширину.
5. **Валидация как в TodoInput** — переиспользование логики (trim, пустая строка, MAX_TODO_LENGTH) и i18n-ключей (errorEmpty, errorMaxLength) обеспечило консистентность UX.
6. **Тесты** — 15 тестов покрывают основной сценарий, edge cases (двойной клик по тексту не переводит в edit, валидация пустой строки) и задержку 400 ms для action buttons.

---

## Сложности

1. **Layout shift при выходе из edit** — первоначально кнопки скрывались/показывались, что вызывало сдвиг интерфейса; потребовалось переосмысление: кнопки всегда в разметке, меняется только `disabled`.
2. **Input сжимается до 0** — при пустом editValue или коротком тексте input в flex-контейнере сжимался; потребовался `edit-wrapper` с `flex: 1 0 auto` и input с `width: 100%`.
3. **BEM-модификатор** — изначально модификатор мог быть на родителе; для корректной стилизации подсветки режима редактирования модификатор `--editing` перенесён на `__content`.
4. **Двойной клик по Save/Cancel** — при быстром двойном клике кнопка могла «сработать» дважды; задержка disabled предотвращает повторное нажатие до завершения анимации/перехода.

---

## Применённые решения

1. **Layout shift** — `actionButtonsEnabled` state + `setTimeout` 400 ms; кнопки всегда рендерятся с `disabled={!actionButtonsEnabled}`; cleanup в `useEffect` при размонтировании.
2. **Input layout** — `edit-wrapper` с `flex: 1 0 auto`, `edit-actions` (кнопки Save/Cancel) снаружи; input внутри с `width: 100%`, `box-sizing: border-box`.
3. **BEM** — `todo-item__content--editing` на сам `__content`; `background-color: $color-bg-hover`, `border-radius` для визуальной подсветки режима редактирования.
4. **Escape** — `e.stopPropagation()` в onKeyDown при Escape, чтобы не закрывать модалки выше по иерархии (если появятся в будущем).

---

## Технические выводы

1. **disabled вместо show/hide** — для элементов, которые временно скрываются, но должны сохранять место в layout, `disabled` с задержкой — предпочтительный паттерн; избегает layout shift и упрощает тесты (fake timers).
2. **Flex: 1 0 auto для input-wrapper** — при input внутри flex-контейнера `flex: 1 0 auto` на wrapper гарантирует, что input занимает доступное пространство и не сжимается до 0.
3. **BEM-модификатор на том элементе, который стилизуется** — при подсветке родительского блока модификатор должен быть на элементе с визуальным изменением, а не на родителе.
4. **Post-implementation refinements** — секция в tasks.md (из опыта после BUILD) полезна для фиксации доработок; можно включить в шаблон для Level 2+.

---

## Процессные выводы

1. **Challenges & Mitigations в плане** — заранее определённые риски (автофокус, Escape, layout shift, валидация) позволили быстро применить решения; реализация прошла без неожиданных блокеров.
2. **Post-implementation refinements** — после первого BUILD обнаружены UI-проблемы (input layout, BEM, дублирование стилей); фиксация в tasks.md и доработка улучшили качество.
3. **Тесты с fake timers** — для проверки задержки 400 ms `vi.useFakeTimers()` и `act(() => vi.advanceTimersByTime(400))` оказались надёжным подходом; явная проверка `toBeDisabled` / `not.toBeDisabled` даёт читаемый тест.

---

## Рекомендации для будущих задач

1. **Inline-редактирование** — при аналогичных задачах использовать паттерн disabled + задержка для action buttons; избегать show/hide для элементов в той же строке.
2. **Flex + input** — при input в flex-контейнере всегда оборачивать в wrapper с `flex: 1 0 auto` и `width: 100%` на input.
3. **Post-implementation** — после BUILD выделять 10–15 минут на ревью UI; фиксировать refinements в tasks.md для последующей рефлексии.
4. **Escape** — при обработке Escape в вложенных компонентах всегда использовать `e.stopPropagation()` для предотвращения всплытия.

---

## Метрики

| Метрика            | Значение                                                                 |
| ------------------ | ------------------------------------------------------------------------ |
| Файлов создано     | 3 (check.svg, close.svg, edit.svg)                                       |
| Файлов изменено    | 6 (TodoItem.tsx, TodoItem.scss, TodoItem.test.tsx, ru/en/uk translation) |
| Тестов добавлено   | 12 (в блоке Inline-редактирование)                                       |
| Соответствие плану | 100%                                                                     |
| Отклонения         | Нет; post-implementation refinements — доработки после BUILD             |

---

## Следующий шаг

REFLECT завершён. Готово к команде `/archive`.
